# 쿠버네티스
- 큰 기업의 경우 대규모 서비스를 운영하고 있기 때문에 최대한 자원을 효율적으로 써야 비용적으로 유리함

## 가상화기술 히스토리
**Linux 자원격리기술**
- 1991년부터 자원들을 격리하여 프로세스들이 독립적인 환경에서 실행될 수 있는 기술들이 개발됨. 하지만 이 기술들은 사용하기 어려워 대중적으로 사용되진 못함.
  - chroot
  - namespace
  - cgroup

**VM 가상화기술**
- 기업부터 일반인들까지 쉽게 다룰 수 있을 정도로 발전됨
  - vmware
  - kvm
  - xen
- 2010.7에 rack space라는 클라우드 기업과 NASA에서 vm을 가상화시켜주는 openstack이라는 오픈소스를 공개함. 당시 openstack에 대한 개발이나 스폰서 활동이 활발하여, 선진 기업들은 자신들의 운영환경을 자동화시키기 위한 시도를 함.
- 시스템 자동화는 되지만 생각보다 효율이 나지 않는걸 느끼게 됨.
- 가장 큰 원인은 근본적으로 VM가상화를 하기 위해 무거운 OS를 띄워야 한다는 것. 이것은 가벼운 서비스 하나를 띄우기 위해서도 더 큰 OS를 띄워야 하는 경우를 발생시킴

**Container 가상화기술**
- dotCloud라는 회사가 Linux의 어려웠던 자원격리기술을 Container라는 개념으로 누구나 쉽게 사용할 수 있게 만듬. 이후 회사를 docker로 변경하며 기술을 오픈소스로 공개함.
- 컨테이너 가상화기술은 서비스간 자원격리를 위해 OS를 별도로 띄우지 않아도 됨.
- OS 기동시간이 없기 때문에 자동화시 매우 빠르고, 자원 효율이 매우 높음.
- 도커는 하나의 서비스를 컨테이너로 가상화시켜 배포하는 개념으로, 많은 서비스를 운영할때 각 서비스를 배포하고 운영하는 역할을 수행하지는 않음.
- 컨테이너 오케스트레이터는 많은 서비스를 배포하고 운영하는 역할을 하는 개념. 여러 컨테이너들을 관리해주는 솔루션이라고 볼 수 있음.

**Container 오케스트레이터**
- 도커의 컨테이너 기술이 오픈소스이기때문에, 많은 회사들이 자사 오케스트레이터 서비스를 출시함.
- 쿠버네티스가 2015.7에 다른 회사보다 뒤늦게 릴리즈 버전을 내놓음.
- 쿠버네티스는 구글이 주도했지만, 여러 업체들이 참여하여 개발하여 타 오케스트레이터에 비해 높은 점유율을 갖게 되어 표준이 됨.

**Kubernetes 클라우드서비스**
- 클라우드 서비스를 제공하는 기업들은 쿠버네티스가 설치되어 있는 인프라를 서비스하고 있음.
- 오픈소스이기 때문에 자신의 운영환경에 맞게 커스텀 할 수 있음.

## 쿠버네티스를 사용하는 이유
- 여러개의 서비스를 운영하는 경우 여러개의 물리적 서버가 필요할 수 있는데, 사용량이 적은 경우에도 서버를 계속 유지해야 함. 하지만 쿠버네티스를 사용하는 경우에는 오토스케일링 기능을 통해 최소한의 자원을 최대로 활용할 수 있음.
- 기존 환경에서는 각 서비스마다 서버의 장애에 대응하기 위해 여분의 백업 서버를 가지고 있어야 함. 하지만 쿠버네티스가 적용된 시스템은 장애가 난 서버 위에 있는 서비스들을 자동으로 다른 서버로 옮겨주는 오토 힐링 기능이 있어 더 적은 여분의 서버로도 장애에 대응할 수 있음.
- 기존에는 서비스의 버전업데이트가 필요한 경우 한번에 모든 서비스를 내렸다가 올리거나, 무중단 서비스를 해야하는 경우 각 서버마다 업데이트 작업을 수행하게 됨. 쿠버네티스는 디플로이먼트라는 오브젝트를 통해 업데이트에 대해 자동으로 처리하도록 지원하고있음.
- 이외에도 쿠버네티스는 여러 기능에 대해 운영 자동화를 지원하고 있음.
- 결론적으로 운영이 용이하고, 더 적은 자원을 필요로 하기 때문에 유지보수 비용이 적어지게 됨. 서비스의 규모가 커질수록 쿠버네티스의 효과가 더 커짐.

## VM vs Container
**Virtual Machine**
- Server > Host OS > Hypervisor(VM 가상화) > 여러개의 Guest OS > 서비스

**Container**
- Server > Host OS > Docker(Container 가상화, docker 이외의 sw 있음) > 서비스와 서비스가 돌아가기 위해 필요한 라이브러리가 있는 이미지
- OS에 다른 버전의 라이브러리들이 설치되어있어도 서비스는 자신의 이미지 안에 있는 라이브러리를 사용하기때문에 안정적으로 시스템이 구동됨.
- 도커의 컨테이너가 이러한 기능을 제공하고, 여러 컨테이너간에 호스트 자원을 분리해서 사용하도록 해줌. Linux의 고유기능인 namespace와 cgroups 기능을 활용함. 네임스페이스는 커널에 관련한 영역을 분리해줌. 씨그룹은 자원에대한 영역을 분리해주는 역할
  - namespace: mnt, pid, net, ipc, uts, user
  - cgroups: memory, CPU, I/O, network
- 컨테이너 가상화 솔루션은 OS에서 제공하는 자원격리 기술을 이용해 컨테이너라는 단위로 서비스를 서비스를 분리할 수 있게 함. 컨테이너 가상화가 설치되어 있는 환경에서는 개발환경에 대한 걱정 없이 배포가 가능함.

시스템 구조적으로 컨테이너는 한 OS를 공유하는 개념, VM은 각각의 OS를 띄워야하는 구조. 그렇기때문에 컨테이너가 훨씬 빠름. VM은 Host OS와 다른 Guest OS 설치 가능, 컨테이너는 리눅스 에서 윈도우용 컨테이너를 사용할 수 없음. 보안적으로 vm은 각각의 Host와 모든 Guest OS간 완전 격리 상태. 그렇기에 하나의 Guest OS가 뚫려도 각각의 VM끼리 피해가지 않음. 컨테이너는 한 컨테이너가 뚫려서 OS 영역에 접근하게 되면 다른 컨테이너도 위험할 수 있음. 이 부분은 보완이 되는 중.

VM에서는 서비스를 개발하는데 있어 하나의 언어를 사용해서 여러 모듈들이 한 서비스에서 같이 돌아감. 이 모듈들 중 하나의 모듈에만 부하가 많이 걸리는 경우에도, 다른 모듈을은 추가로 띄울 필요가 없으나 한 패키지이기 때문에 VM을 하나 더 생성하여 모든 모듈을 띄우게 됨. 자원사용과 성능적으로 Guest OS가 두 개가 올라가게 됨. 반면 컨테이너는 마이크로 서비스로 모듈별로 서비스를 쪼개 각각의 컨테이너에 담음. 그리고 해당 모듈은 각 모듈에 맞는 최적화된 개발 언어를 선택할 수 있음. 여기서 쿠버네티스는 여러 컨테이너나 한 컨테이너를 Pod라는 개념으로 담을 수 있음. Pod는 하나의 배포 단위임. 사용자는 손쉽게 필요한 Pod만 확장할 수 있음. 쿠버네티스는 모듈별로 나눠 개발했을때 큰 효과를 볼 수 있음.

## 쿠버네티스 시작하기
1. 리눅스
   - Node.js를 실행할 수 있는 패키지를 설치해서 앱 제작 
2. 도커
   - 도커 허브(공개 컨테이너 이미지 저장소)에서 Node.js를 실행 가능한 컨테이너 이미지를 가져옴
   - 1번에서 만든 앱을 가져온 이미지와 합쳐서 하나의 컨테이너로 생성
      ```Dockerfile
      FROM node:slim
      EXPOSE 8000
      COPY hello.js .
      CMD node hello.js
      ```
    - 이렇게 만든 도커 이미지를 다시 도커 허브에 업로드
3. 쿠버네티스
   - 파드 내부에 컨테이너를 만들때 도커 허브에서 2번에서 만든 컨테이너 이미지를 받아와 구동 
      ```yml
      # Pod
      apiVersion: v1
      kind: Pod
      metadata:
        name: hello-pod # 파드명
        labels:
          app: hello
      spec:
        containers:
        - name: hello-container # 생성할 컨테이너명
          image: bubblecocoa/hello # 가져올 이미지
          ports:
          - containerPort: 8000 # 오픈할 포트
      ```
      ```yml
      # Service
      apiVersion: v1
      kind: Service
      metadata:
        name: hello-svc # 서비스명
      spec:
        selector:
          app: hello
        ports:
          - port: 8200 # 외부 오픈 포트
            targetPort: 8000 # 컨테이너 포트
        externalIPs:
        - 192.168.0.30 # 접근 허용 IP
      ```
   - 파드는 서비스를 통해서만 접근할 수 있음. 파드는 labels로 앱 이름을 노출시키고, 서비스는 selector에 해당 앱 이름을 기입해 서비스와 파드를 연결함.

## 쿠버네티스 개요
- 쿠버네티스는 하나의 물리적인 Master 서버를 가짐. 마스터에는 여러 노드(물리적 서버)를 가지고 연결됨. 이것이 하나의 쿠버네티스 클러스터 개념으로 묶임.
- 마스터는 쿠버네티스의 전반적인 기능들을 컨트롤 하는 역할. 노드들은 자원을 제공하는 역할. 클러스터 자원을 늘리고싶다면 노드를 계속 추가하면 됨.
- 클러스터 내부에 Namespace가 쿠버네티스 오브젝트를 독립된 공간으로 분리함.
- 네임스페이스에는 쿠버네티스 최소 배포단위인 파드들이 있고, 이 파드들을 외부로부터 연결 가능하도록 IP를 할당해주는 서비스가 있음. 서비스는 다른 네임스페이스에 있는 파드는 연결할 수 없음.
- 파드 안에는 여러 컨테이너가 있을 수 있음. 컨테이너 하나당 하나의 앱이 동작함. 즉, 파드 하나에는 여러 앱이 동작할 수 있음.
- 파드는 재생성시 데이터를 유지하지 않음. Volume을 만들어 연결하여 데이터를 이곳에 별도로 저장하여 파드가 재생성 되어도 데이터가 없어지는 문제를 해결할 수 있음. 도커와 같은 개념
- 네임스페이스에 ResourceQuota / LimitRange 를 지정하여 한 네임스페이스에서 사용할 수 있는 자원의 양을 제한할 수 있음. Pod의 갯수 제한이나, CPU, Memory도 제한 가능
- 파드 생성시 ConfigMap / Secret을 통해 환경변수 값을 넣거나 파일을 마운트 시킬 수 있음. 
- Controller가 파드들을 관리하는 역할을 수행하는데, 컨트롤러는 종류가 다양함.
  - Replication Controller, ReplicaSet이 기본적인 컨트롤러. 파드가 죽으면 감지해서 다시 살리거나, 파드의 갯수를 늘리거나 줄일 수 있음.
  - Deployment는 배포 후 파드들을 새 버전으로 업그레이드 함. 업그레이드 중 문제가 생기면 롤백 하도록 도와줌.
  - DaemonSet은 한 노드에 파드가 하나씩만 유지되도록 함. 이렇게 사용해야 하는 모듈들이 있기 때문에 사용.
  - CronJob은 어떤 특정 작업만 수행하고 종료시켜야 하는 일을 할 때 파드가 그렇게 동작하도록 함. 이런 작업을 주기적으로 실행시켜야 할 때 사용함.